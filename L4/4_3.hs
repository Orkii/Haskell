--Видно, что число 125874 и его двойник 251748 содержат точно такие же цифры, но в другом порядке.
--
--Найдите наименьшее положительное целое число x , такое что 2 x , 3 x , 4 x , 5 x и 6 x содержат одинаковые цифры.

import Data.List



--main = mod (28433 * 2^7830457 + 1) 10^10
aaaa = takeRNaive 10 (show (28433 * (2^7830457) + 1))

---Простое число 41 можно представить в виде суммы шести последовательных простых чисел:
--
---41 = 2 + 3 + 5 + 7 + 11 + 13
---Это самая длинная сумма последовательных 
---простых чисел, которая в сумме дает простое число меньше ста.
---
---Самая длинная сумма последовательных 
---простых чисел меньше тысячи, которая добавляется к простому числу,
---содержит 21 член и равна 953.
---
---Какое простое число меньше миллиона 
---можно представить в виде суммы 
---самых последовательных простых чисел?
--
--mport Debug.Trace
--mport Data.List
--
--sSimple :: Int -> Bool
--sSimple1 :: Int -> Int -> Bool
--sSimple1 s x | (s + 1 < x * 2) = True
--			  | mod s x == 0 = False
--             | True = isSimple1 s (x+1)
--sSimple now = isSimple1 now 2
--
---isSimple k = if k > 1 then null [ x | x <- [2..k - 1], k `mod` x == 0] else False
--
--impele = 2:next 3 where
--	next x | isSimple x = x:(next (x+2))
--		   | True = (next (x+2))
--		   
--
--
--heck :: (Int, Int) -> (Int, Int)
--
--heck (a,b) | isSimple b == True = (a,b)
--			| True = (0,0)
--
--roc  :: [Int] -> (Int, Int) -> Int -> (Int, Int)
--rocS :: [Int] -> (Int, Int) -> Int -> (Int, Int)
--roc (h:ts) (i, now) max | (now + h > max) && (isSimple now) = (i, now)	
--						 | (now + h > max) = (0,0)
--						 | True = last (sort [(proc ts (0, 0) max),  (procS ts (i+1, (now + h)) max)] )
--
--rocS (h:ts) (i, now) max | (now + h > max) && (isSimple now) = (i, now)	
--                         | (now + h > max) 				  = (0,0)
--						  | True = last (sort [(check(i, now)) , (procS ts (i+1, (now + h)) max)] )
--						  
---roc  :: [Int] -> (Int, Int) -> Int -> [(Int, Int)]
---rocS :: [Int] -> (Int, Int) -> Int -> [(Int, Int)]
---proc (h:ts) (i, now) max | (now + h > max) && (isSimple now) = [(i, now)]	
---						 | (now + h > max) = []
---						 | True = (proc ts (0, 0) max) ++ (procS ts (i+1, (now + h)) max) 
---
---procS (h:ts) (i, now) max | (now + h > max) && (isSimple now) = [(i, now)]	
---                          | (now + h > max) 					= []
---						  | True = (check(i, now)) ++ (procS ts (i+1, (now + h)) max) 
--
---main = take 100 simpele  
--ain3 x = proc simpele (0, 0) x
---main2 = take 30 (proc simpele (0, 0) 100)
---main1 = take 30 simpele 
